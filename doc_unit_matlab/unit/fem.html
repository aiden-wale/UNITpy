<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fem</title>
  <meta name="keywords" content="fem">
  <meta name="description" content="This function tries to compute the maximum likelihood estimate of a">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">unit</a> &gt; fem.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for unit&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>fem
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This function tries to compute the maximum likelihood estimate of a</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function g = fem(z,mm,opt); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> This function tries to compute the maximum likelihood estimate of a
 state-space model from frequency domain measurements using the
 Expectation-Maximisation approach. This function is not meant to be
 called directly.  Rather, it is intended to be called by using the
 est.m algorithm, with OPT.alg='em' specified.

     Usage is:  G = fem(Z,M,OPT);

     where

       Z:        Frequency-Response-Function (FRF) data. Z.y(i,j,k) holds
                 the i'th output, j'th input FRF data for the k'th
                 frequency point. The frequency points are stored in Z.w.
 M.ss.A,B,C,D:   Initial state space model structure guess.  These *cannot*
                 be specified simply as integer orders, they must be an
                 actual full state space system parameterisation.
   M.ss.Q,R:     Covariance matrices for states and outputs, respectively.
       M.op:     set to 'q' for shift and 's' for Laplace.  Default = 'q'.
       M.T:      sampling period (ignored for q operator case).  Default=1
       M.w:      vector of frequencies at which to calculate frequency
                 response of estimated model.  Specify in real frequency,
                 not normalised.  Default is 3 decades up to folding freq.
      OPT:       Data structure which defines options for the estimation
                 algorithm as follows:
      OPT.miter: Maximum number of iterations in search for minimum.
      OPT.dsp:   Control of output to screen 0=&gt;quiet,1=&gt;verbose.
  OPT.stoptol:   Stopping criteria tolerance (1e-3 by default).
      G:         Data structure which specifies the estimated model as
                 follows:
  G.ss.A,B,C,D:  [A,B,C,D] matrices defining estimated state space model.
      G.G:       Matrix of frequency responses.  If the system has multiple
                 inputs and multpile outputs, then this matrix is 3
                 dimensional, with one `page' per output, and the i'th
                 column of the j'th page (ie G.G(i,j,:)) being the
                 frequency response from input i to ouput j.


    Written by Brett Ninness, School of Elec. Eng and Comp. Sci.
               Adrian Wills   University of Newcastle
                              Australia.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="argmin.html" class="code" title="function [theta,cost_log,ARGS] = argmin(Z,FUN,theta,OPT,ARGS,fargs)">argmin</a>	Function to find minimum of function that is defined by user supplied</li><li><a href="cmpcost.html" class="code" title="function c = cmpcost(ejw,de)">cmpcost</a>	</li><li><a href="fsmooth.html" class="code" title="function [PP,Pssum,Psejw,Psej2,MSE,LL] = fsmooth(V,S,Vi,B,C,D,Q,R,w,ejw,Y,U,discrete)">fsmooth</a>	/* Get sizes */</li><li><a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>	</li><li><a href="rchol.html" class="code" title="function [A] = rchol(A);">rchol</a>	A function for computing the Cholesky factorisation,</li><li><a href="sstotf.html" class="code" title="function g=sstotf(G);">sstotf</a>	SSTOTF: Function to add the polynomial form descriptions to a model</li><li><a href="startZ.html" class="code" title="function Z = startZ(Z)">startZ</a>	This function accepts a data structure and tries to interpret what type</li><li><a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>	</li><li><a href="vec.html" class="code" title="function x = vec(X)">vec</a>	Function to make a vector out of a matrix by stacking it's columns on top</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="em.html" class="code" title="function G = em(Z,M,OPT);">em</a>	EM: Function to find maximum likelihood estimates of state space mdoel</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [Phi,Psi,Sigma,LL,MSE] = fem_estep(N,n,m,p,y,u,ejw,a,b,c,d,Q,R,op,w)</a></li><li><a href="#_sub2" class="code">function [a,b,c,d,Q,R,del1,del2,kk,numit,gnorm] = fem_mstep(N,n,m,p,a,b,c,d,ejw,Phi,Psi,Sigma,opt,del1,del2,itn);</a></li><li><a href="#_sub3" class="code">function [G,i,gnorm] = minab(N,n,m,p,ejw,G,Lambda,Omega,Pi);</a></li><li><a href="#_sub4" class="code">function [G,i,gnorm] = mincd(N,n,m,p,ejw,G,Phi,Psi,Sigma);</a></li><li><a href="#_sub5" class="code">function [c,g,H1,H2] = costab(N,n,m,p,ejw,G,Lambda,Omega,Pi);</a></li><li><a href="#_sub6" class="code">function [c,g,H1,H2] = costcd(N,n,m,p,ejw,G,Phi,Psi,Sigma);</a></li><li><a href="#_sub7" class="code">function [G,del,kk,numit,gnorm] = argmin(costfn,N,n,m,p,G,ejw,Phi,Psi,Sigma,opt,del);</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% This function tries to compute the maximum likelihood estimate of a</span>
0002 <span class="comment">% state-space model from frequency domain measurements using the</span>
0003 <span class="comment">% Expectation-Maximisation approach. This function is not meant to be</span>
0004 <span class="comment">% called directly.  Rather, it is intended to be called by using the</span>
0005 <span class="comment">% est.m algorithm, with OPT.alg='em' specified.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%     Usage is:  G = fem(Z,M,OPT);</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%     where</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%       Z:        Frequency-Response-Function (FRF) data. Z.y(i,j,k) holds</span>
0012 <span class="comment">%                 the i'th output, j'th input FRF data for the k'th</span>
0013 <span class="comment">%                 frequency point. The frequency points are stored in Z.w.</span>
0014 <span class="comment">% M.ss.A,B,C,D:   Initial state space model structure guess.  These *cannot*</span>
0015 <span class="comment">%                 be specified simply as integer orders, they must be an</span>
0016 <span class="comment">%                 actual full state space system parameterisation.</span>
0017 <span class="comment">%   M.ss.Q,R:     Covariance matrices for states and outputs, respectively.</span>
0018 <span class="comment">%       M.op:     set to 'q' for shift and 's' for Laplace.  Default = 'q'.</span>
0019 <span class="comment">%       M.T:      sampling period (ignored for q operator case).  Default=1</span>
0020 <span class="comment">%       M.w:      vector of frequencies at which to calculate frequency</span>
0021 <span class="comment">%                 response of estimated model.  Specify in real frequency,</span>
0022 <span class="comment">%                 not normalised.  Default is 3 decades up to folding freq.</span>
0023 <span class="comment">%      OPT:       Data structure which defines options for the estimation</span>
0024 <span class="comment">%                 algorithm as follows:</span>
0025 <span class="comment">%      OPT.miter: Maximum number of iterations in search for minimum.</span>
0026 <span class="comment">%      OPT.dsp:   Control of output to screen 0=&gt;quiet,1=&gt;verbose.</span>
0027 <span class="comment">%  OPT.stoptol:   Stopping criteria tolerance (1e-3 by default).</span>
0028 <span class="comment">%      G:         Data structure which specifies the estimated model as</span>
0029 <span class="comment">%                 follows:</span>
0030 <span class="comment">%  G.ss.A,B,C,D:  [A,B,C,D] matrices defining estimated state space model.</span>
0031 <span class="comment">%      G.G:       Matrix of frequency responses.  If the system has multiple</span>
0032 <span class="comment">%                 inputs and multpile outputs, then this matrix is 3</span>
0033 <span class="comment">%                 dimensional, with one `page' per output, and the i'th</span>
0034 <span class="comment">%                 column of the j'th page (ie G.G(i,j,:)) being the</span>
0035 <span class="comment">%                 frequency response from input i to ouput j.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%    Written by Brett Ninness, School of Elec. Eng and Comp. Sci.</span>
0039 <span class="comment">%               Adrian Wills   University of Newcastle</span>
0040 <span class="comment">%                              Australia.</span>
0041 
0042 <span class="comment">% Copyright (C) Brett Ninness.</span>
0043 
0044 <a name="_sub0" href="#_subfunctions" class="code">function g = fem(z,mm,opt);</a>
0045 
0046 <span class="comment">%  Flag to we can make this same function work in both MATLAB or OCTAVE</span>
0047 oct = exist(<span class="string">'OCTAVE_VERSION'</span>);
0048 
0049 <span class="comment">% Set some options if they have not been specified</span>
0050 <span class="keyword">if</span> ~isfield(opt,<span class="string">'miter'</span>)   opt.miter   = 300;        <span class="keyword">end</span>; <span class="comment">% default number of total iterations</span>
0051 <span class="keyword">if</span> ~isfield(opt,<span class="string">'dsp'</span>)     opt.dsp     = 0;          <span class="keyword">end</span>; <span class="comment">% display iteration info (dsp = 1 to display)</span>
0052 <span class="keyword">if</span> ~isfield(opt,<span class="string">'delta'</span>)   opt.delta   = 1e3;        <span class="keyword">end</span>; <span class="comment">% default trust region radius</span>
0053 <span class="keyword">if</span> ~isfield(opt,<span class="string">'bismax'</span>)  opt.bismax  = 50;         <span class="keyword">end</span>; <span class="comment">% maximum number of trust region radius bisections</span>
0054 <span class="keyword">if</span> ~isfield(opt,<span class="string">'stoptol'</span>) opt.stoptol = 1e-3;       <span class="keyword">end</span>; <span class="comment">% Newton decrement stop tolerance</span>
0055 <span class="keyword">if</span> ~isfield(opt,<span class="string">'optit'</span>)   opt.optit   = 100;        <span class="keyword">end</span>; <span class="comment">% default number of optimisation iterations</span>
0056 <span class="keyword">if</span> ~isfield(opt,<span class="string">'smeth'</span>)   opt.smeth   = <span class="string">'bilin'</span>;    <span class="keyword">end</span>; <span class="comment">% default method for dealing with continuous models (can also be direct = use j*w)</span>
0057 <span class="keyword">if</span> ~isfield(opt,<span class="string">'dspbode'</span>) opt.dspbode = 0;          <span class="keyword">end</span>; <span class="comment">% display bode plot at each iteration</span>
0058 <span class="keyword">if</span> ~isfield(opt,<span class="string">'use_old'</span>) opt.use_old = 1;          <span class="keyword">end</span>; <span class="comment">% Old or new version of M step</span>
0059 
0060 <span class="comment">% Detect if gui is running</span>
0061 gui = 0; guih = [];
0062 <span class="keyword">if</span> isfield(opt,<span class="string">'gui'</span>),
0063  <span class="keyword">if</span> ~isempty(opt.gui)
0064   gui  = 1;         <span class="comment">%GUI is running</span>
0065   guih = opt.gui;   <span class="comment">%GUI handle</span>
0066  <span class="keyword">end</span>
0067 <span class="keyword">end</span>
0068 
0069 <span class="comment">% Extract data</span>
0070 z = <a href="startZ.html" class="code" title="function Z = startZ(Z)">startZ</a>(z);
0071 y = z.y;
0072 w = z.w(:)';
0073 N = max(size(y));
0074 
0075 <span class="comment">% Perform the pre-warp if continuous</span>
0076 <span class="keyword">if</span> strcmp(mm.op,<span class="string">'s'</span>),
0077  <span class="keyword">switch</span> opt.smeth
0078   <span class="keyword">case</span> <span class="string">'bilin'</span>,
0079    T      = 2*pi/max(w);
0080    Tq     = 1;
0081    w      = 2*atan(w*T/2);
0082    mm.op  = <span class="string">'q'</span>;
0083    opsave = <span class="string">'s'</span>;
0084    mm.T   = 1;
0085    ejw = exp(j*Tq*w); ejw = ejw(:).';
0086 
0087   <span class="keyword">otherwise</span> <span class="comment">% use a direct approach</span>
0088    opsave=<span class="string">'s'</span>;
0089    ejw = j*w; ejw = ejw(:).';
0090  <span class="keyword">end</span>
0091 <span class="keyword">else</span>
0092  Tq = mm.T;
0093  opsave = <span class="string">'q'</span>;
0094  ejw = exp(j*Tq*w); ejw = ejw(:).';
0095 <span class="keyword">end</span>
0096 
0097 <span class="comment">% Set initial values</span>
0098 del1 = opt.delta;
0099 del2 = opt.delta;
0100 a = mm.ss.A;
0101 b = mm.ss.B;
0102 c = mm.ss.C;
0103 d = mm.ss.D;
0104 n = size(a,1);
0105 m = size(b,2);
0106 p = size(c,1);
0107 nnm=n*(n+m); nn=n*n;
0108 <span class="keyword">if</span> ~isfield(mm.ss,<span class="string">'Q'</span>),
0109  Q = 10*eye(n);
0110 <span class="keyword">else</span>
0111  Q = mm.ss.Q;
0112 <span class="keyword">end</span>
0113 <span class="keyword">if</span> ~isfield(mm.ss,<span class="string">'R'</span>),
0114  R = eye(p);
0115 <span class="keyword">else</span>
0116  R = mm.ss.R;
0117 <span class="keyword">end</span>
0118 
0119 <span class="comment">% Make input equal to the identity for each w(k) if not supplied by user</span>
0120 <span class="keyword">if</span> ~isfield(z,<span class="string">'u'</span>),
0121  z.u = zeros(m,m,N);
0122  <span class="keyword">for</span> k=1:N, z.u(:,:,k) = eye(m); <span class="keyword">end</span>
0123 <span class="keyword">elseif</span> isempty(z.u),
0124  z.u = zeros(m,m,N);
0125  <span class="keyword">for</span> k=1:N, z.u(:,:,k) = eye(m); <span class="keyword">end</span>
0126 <span class="keyword">end</span>
0127 u = z.u;
0128 
0129 <span class="comment">% Modify system matrices for prewarp</span>
0130 <span class="keyword">if</span> strcmp(opsave,<span class="string">'s'</span>) &amp;&amp; strcmp(opt.smeth,<span class="string">'bilin'</span>),
0131  a=pinv(eye(n)-(T/2)*a)*((T/2)*a+eye(n));
0132  b=(sqrt(T)/2)*(a*b+b);
0133  c=(sqrt(T)/2)*(c*a+c);
0134  d=d+c*inv(eye(n)+a)*b;
0135  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'Using Bilinear transform to handle continuous domain data.'</span>,gui,guih)
0136 <span class="keyword">end</span>
0137 
0138 <span class="comment">% Display iteration info if asked to</span>
0139 <span class="keyword">if</span> opt.dsp,
0140  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'------------------------------------------------------------------------------------------'</span>,gui,guih);
0141  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(sprintf(<span class="string">'%8s%20s%20s%10s%10s%20s'</span>,<span class="string">'Iter #'</span>,<span class="string">'Log-Likelihood'</span>,<span class="string">'Pred. Error'</span>,<span class="string">'Op. Its'</span>,<span class="string">'No. Bis.'</span>,<span class="string">'Newton-Decrement'</span>),gui,guih);
0142  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'------------------------------------------------------------------------------------------'</span>,gui,guih);
0143 <span class="keyword">end</span>
0144 
0145 <span class="keyword">if</span> opt.dspbode,
0146  sysG = frd(z.y,w);
0147  <span class="keyword">if</span> mm.op==<span class="string">'q'</span>
0148   bode(sysG,ss(a,b,c,d,mm.T),w); drawnow;
0149  <span class="keyword">elseif</span> mm.op==<span class="string">'s'</span>
0150   bode(sysG,ss(a,b,c,d),w); drawnow;
0151  <span class="keyword">end</span>
0152 <span class="keyword">end</span>
0153 
0154 <span class="comment">% start main EM loop</span>
0155 final_print = 0; <span class="comment">%=1 prints final iteration information</span>
0156 numit       = 0; <span class="comment">%number of iterations taken in minloop</span>
0157 kk          = 0; <span class="comment">%number of bisections return from minloop</span>
0158 gnorm       = 0; <span class="comment">%gradient norm returned from minimisation step</span>
0159 count       = 0; <span class="comment">%counter for main loop</span>
0160 <span class="keyword">while</span> count&lt;opt.miter,
0161  count=count+1; <span class="comment">%update main loop counter</span>
0162 
0163  <span class="comment">%keyboard</span>
0164  
0165  <span class="comment">% Call E-STEP</span>
0166  <span class="comment">%try</span>
0167   [Phi,Psi,Sigma,LL(count),MSE(count)] = <a href="#_sub1" class="code" title="subfunction [Phi,Psi,Sigma,LL,MSE] = fem_estep(N,n,m,p,y,u,ejw,a,b,c,d,Q,R,op,w)">fem_estep</a>(N,n,m,p,y,u,ejw,a,b,c,d,Q,R,mm.op,w);
0168  <span class="comment">%catch</span>
0169 <span class="comment">%   if opt.dsp, udisp('Could not complete E-Step',gui,guih); end</span>
0170 <span class="comment">%   final_print=1;</span>
0171 <span class="comment">%   break;</span>
0172 <span class="comment">%  end</span>
0173 
0174  <span class="comment">% Check to see if we have gone backwards and quit if necessary</span>
0175  <span class="keyword">if</span> count&gt;1 &amp; LL(count)&lt;LL(count-1),
0176   <span class="comment">% Recall the last system before the decrease</span>
0177   a=as; b=bs; c=ccs; d=ds; Q=qs; R=rs;
0178   <span class="keyword">if</span> opt.dsp, <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'Decrease in Log-Likelihood'</span>,gui,guih); <span class="keyword">end</span>
0179   final_print=1;
0180   <span class="keyword">break</span>;
0181  <span class="keyword">end</span>
0182 
0183  <span class="comment">% Check to see if we can stop because MSE has gone below user defined value</span>
0184  <span class="keyword">if</span> isfield(opt,<span class="string">'sv'</span>),
0185   <span class="keyword">if</span> MSE(count)&lt;opt.sv,
0186    <span class="keyword">if</span> opt.dsp, <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'MSE less than OPT.sv'</span>,gui,guih); <span class="keyword">end</span>
0187    final_print=1;
0188    <span class="keyword">break</span>;
0189   <span class="keyword">end</span>
0190  <span class="keyword">end</span>
0191 
0192  <span class="comment">% Save the system matrices in case we decrease the likelihood</span>
0193  as=a; bs=b; ccs=c; ds=d; qs=Q; rs=R;
0194     
0195  <span class="comment">% Reset delta's for each pass through minimisation loop</span>
0196  del1=opt.delta; del2=opt.delta;
0197 
0198  <span class="comment">% Call M-STEP</span>
0199  <span class="comment">%try</span>
0200   [a,b,c,d,Q,R,del1,del2,kk,numit,gnorm] = <a href="#_sub2" class="code" title="subfunction [a,b,c,d,Q,R,del1,del2,kk,numit,gnorm] = fem_mstep(N,n,m,p,a,b,c,d,ejw,Phi,Psi,Sigma,opt,del1,del2,itn);">fem_mstep</a>(N,n,m,p,a,b,c,d,ejw,Phi,Psi,Sigma,opt,del1,del2,count);
0201 <span class="comment">%  catch</span>
0202 <span class="comment">%   if opt.dsp, udisp('Could not complete M-Step',gui,guih); end</span>
0203 <span class="comment">%   final_print=1;</span>
0204 <span class="comment">%   break;</span>
0205 <span class="comment">%  end</span>
0206 
0207  <span class="comment">% Provide iteration update if required</span>
0208  <span class="keyword">if</span> opt.dsp,
0209   <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(sprintf(<span class="string">'%8i%20.5e%20.5e%10i%10i%20.5e'</span>,count,LL(count),MSE(count),numit,kk,gnorm),gui,guih)
0210  <span class="keyword">end</span>
0211 
0212  <span class="comment">% Display bode plot if requested</span>
0213  <span class="keyword">if</span> opt.dspbode,
0214   <span class="keyword">if</span> mm.op==<span class="string">'q'</span>
0215    bode(sysG,ss(a,b,c,d,mm.T),w); drawnow;
0216   <span class="keyword">elseif</span> mm.op==<span class="string">'s'</span>
0217    bode(sysG,ss(a,b,c,d),w); drawnow;
0218   <span class="keyword">end</span>
0219  <span class="keyword">end</span>
0220  
0221 <span class="keyword">end</span>
0222 
0223 <span class="comment">% Provide iteration update if required</span>
0224 <span class="keyword">if</span> opt.dsp &amp; final_print,
0225  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(sprintf(<span class="string">'%8i%20.5e%20.5e%10i%10i%20.5e'</span>,count,LL(count),MSE(count),numit,kk,gnorm),gui,guih)
0226 <span class="keyword">end</span>
0227 
0228 <span class="keyword">if</span> opt.dsp,
0229  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'------------------------------------------------------------------------------------------'</span>,gui,guih);
0230 <span class="keyword">end</span>
0231 
0232 <span class="comment">% Now put new things into g</span>
0233 <span class="keyword">if</span> strcmp(opsave,<span class="string">'s'</span>) &amp; strcmp(opt.smeth,<span class="string">'bilin'</span>),
0234  aa   = inv(eye(size(a))+a);
0235  a    = (2/T) * aa * (a-eye(size(a)));
0236  d    = d - c*aa*b;
0237  b    = (2/sqrt(T))*aa*b;
0238  c    = (2/sqrt(T))*c*aa;
0239  mm.T = 0;
0240 <span class="keyword">end</span>
0241 mm.op   = opsave;
0242 g       = mm;
0243 g.ss.A  = a;
0244 g.ss.B  = b;
0245 g.ss.C  = c;
0246 g.ss.D  = d;
0247 g.ss.Q  = Q;
0248 g.ss.R  = R;
0249 g.ss.K  = [];
0250 g.ss.F  = [];
0251 g.ss.G  = [];
0252 g.LL    = LL;
0253 g.MSE   = MSE;
0254 <span class="keyword">try</span>,
0255  <span class="keyword">if</span> isfield(mm,<span class="string">'T'</span>), g.T = mm.T; <span class="keyword">elseif</span> strcmp(mm.op,<span class="string">'q'</span>), g.T = 1; <span class="keyword">else</span> g.T=0; <span class="keyword">end</span>
0256  <span class="keyword">if</span> isfield(mm,<span class="string">'w'</span>), g.w = mm.w; <span class="keyword">else</span> g.w = z.w; <span class="keyword">end</span>
0257  g.op    = mm.op;
0258  g.delay = zeros(m,1);
0259  g.type  = <span class="string">'ss'</span>;
0260 <span class="keyword">catch</span>,
0261 
0262 <span class="keyword">end</span>
0263 <span class="comment">%g = addtf(g);</span>
0264 
0265 g = <a href="sstotf.html" class="code" title="function g=sstotf(G);">sstotf</a>(g);
0266 g.var = 1;
0267 
0268 <span class="comment">% Add legend for prospective plotting</span>
0269 g.disp.legend=[<span class="string">'Estimated '</span>,g.type,<span class="string">' model'</span>];
0270 g.alg=<span class="string">'EM'</span>; <span class="comment">% Record that block solution was used</span>
0271 
0272 
0273 <span class="comment">% Finally make sure we give a Matlab system form</span>
0274 <span class="keyword">if</span> ~oct
0275  <span class="keyword">if</span> strcmp(mm.op,<span class="string">'s'</span>),
0276   g.ss.sys=ss(g.ss.A,g.ss.B,g.ss.C,g.ss.D);
0277  <span class="keyword">else</span>,
0278   g.ss.sys=ss(g.ss.A,g.ss.B,g.ss.C,g.ss.D,mm.T);
0279  <span class="keyword">end</span>
0280 <span class="keyword">end</span>;
0281 
0282 <span class="keyword">return</span>;
0283 <span class="comment">%--------------------------------------------------------------------------</span>
0284 <span class="comment">% END OF MAIN ROUTINE</span>
0285 <span class="comment">%--------------------------------------------------------------------------</span>
0286 
0287 
0288 
0289 <span class="comment">%--------------------------------------------------------------------------</span>
0290 <span class="comment">% START OF E-STEP ROUTINE</span>
0291 <span class="comment">%--------------------------------------------------------------------------</span>
0292 
0293 <a name="_sub1" href="#_subfunctions" class="code">function [Phi,Psi,Sigma,LL,MSE] = fem_estep(N,n,m,p,y,u,ejw,a,b,c,d,Q,R,op,w)</a>
0294 <span class="keyword">if</span> strcmp(op,<span class="string">'q'</span>), discrete=1;   <span class="keyword">else</span> discrete=0;   <span class="keyword">end</span>
0295 [ve,de]=eig(a); de=diag(de); vei=ve\eye(size(ve));
0296 [PP,Pssum,Psejw,Psej2,MSE,LL]=<a href="fsmooth.html" class="code" title="function [PP,Pssum,Psejw,Psej2,MSE,LL] = fsmooth(V,S,Vi,B,C,D,Q,R,w,ejw,Y,U,discrete)">fsmooth</a>(ve,de,vei,b,c,d,Q,R,w,ejw,y,u,discrete);
0297 MSE=MSE/N; PP=PP*PP';
0298 Phi=PP(1:n+p,1:n+p); Phi(1:n,1:n)=Phi(1:n,1:n)+Psej2;
0299 Psi=PP(1:n+p,n+p+1:end); Psi(1:n,1:n)=Psi(1:n,1:n)+Psejw;
0300 Sigma=PP(n+p+1:<span class="keyword">end</span>,n+p+1:end); Sigma(1:n,1:n)=Sigma(1:n,1:n)+Pssum;
0301 <span class="comment">%--------------------------------------------------------------------------</span>
0302 <span class="comment">% END OF E_STEP</span>
0303 <span class="comment">%--------------------------------------------------------------------------</span>
0304 
0305 
0306 <span class="comment">%--------------------------------------------------------------------------</span>
0307 <span class="comment">% START OF M-STEP ROUTINE</span>
0308 <span class="comment">%--------------------------------------------------------------------------</span>
0309 
0310 <a name="_sub2" href="#_subfunctions" class="code">function [a,b,c,d,Q,R,del1,del2,kk,numit,gnorm] = fem_mstep(N,n,m,p,a,b,c,d,ejw,Phi,Psi,Sigma,opt,del1,del2,itn);</a>
0311 
0312 <span class="keyword">if</span> itn == 0,
0313  cdi = real(Psi(n+1:<span class="keyword">end</span>,:))/real(Sigma);
0314  abi = real(Psi(1:n,:))/real(Sigma);
0315 <span class="keyword">else</span>
0316  cdi = [c d];
0317  abi = [a b];
0318 <span class="keyword">end</span>
0319 
0320 <span class="comment">% Maximise Q function with respect to A,B,C,D system matrices</span>
0321 <span class="keyword">if</span> opt.use_old,
0322  [cd,del2,kk,numit,gnorm] = <a href="argmin.html" class="code" title="function [theta,cost_log,ARGS] = argmin(Z,FUN,theta,OPT,ARGS,fargs)">argmin</a>(<span class="string">'costcd'</span>,N,n,m,p,cdi,ejw,Phi(n+1:<span class="keyword">end</span>,n+1:end),Psi(n+1:<span class="keyword">end</span>,:),Sigma,opt,del2);
0323  [ab,del1,kk,numit,gnorm] = <a href="argmin.html" class="code" title="function [theta,cost_log,ARGS] = argmin(Z,FUN,theta,OPT,ARGS,fargs)">argmin</a>(<span class="string">'costab'</span>,N,n,m,p,abi,ejw,Phi(1:n,1:n),Psi(1:n,:),Sigma,opt,del1);
0324 <span class="keyword">else</span>
0325  [cd,numit,gnorm] = <a href="#_sub4" class="code" title="subfunction [G,i,gnorm] = mincd(N,n,m,p,ejw,G,Phi,Psi,Sigma);">mincd</a>(N,n,m,p,ejw,cdi,Phi(n+1:<span class="keyword">end</span>,n+1:end),Psi(n+1:<span class="keyword">end</span>,:),Sigma);
0326  [ab,numit,gnorm] = <a href="#_sub3" class="code" title="subfunction [G,i,gnorm] = minab(N,n,m,p,ejw,G,Lambda,Omega,Pi);">minab</a>(N,n,m,p,ejw,abi,Phi(1:n,1:n),Psi(1:n,:),Sigma);
0327  kk   = 1;
0328  del1 = 1;
0329  del2 = 1;
0330 <span class="keyword">end</span>
0331 
0332 <span class="comment">% If no iteration, then make sure values are sensible</span>
0333 <span class="keyword">if</span> opt.optit==0, kk=0; gnorm=0; <span class="keyword">end</span>
0334 
0335 <span class="comment">% Combine the A B C and D matrices into G = Gamma matrix</span>
0336 G=[ab;cd];
0337 
0338 <span class="comment">% Form the covariance matrix Pi</span>
0339 CP = <a href="rchol.html" class="code" title="function [A] = rchol(A);">rchol</a>([Phi -Psi;-Psi' Sigma]);
0340 PP = CP*[eye(n+p);G'];
0341 Pi = (PP'*PP)/N;
0342 
0343 <span class="comment">% Extract new system matrices and covariance matrices</span>
0344 a = G(1:n,1:n);
0345 b = G(1:n,n+1:end);
0346 c = G(n+1:<span class="keyword">end</span>,1:n);
0347 d = G(n+1:<span class="keyword">end</span>,n+1:end);
0348 Q = Pi(1:n,1:n);
0349 R = Pi(n+1:<span class="keyword">end</span>,n+1:end);
0350 
0351 <span class="comment">%----------------------------------------------------------------</span>
0352 <span class="comment">% END OF M-STEP</span>
0353 <span class="comment">%----------------------------------------------------------------</span>
0354 
0355 <a name="_sub3" href="#_subfunctions" class="code">function [G,i,gnorm] = minab(N,n,m,p,ejw,G,Lambda,Omega,Pi);</a>
0356 
0357 [CC,pC]=chol([Lambda -Omega;-Omega' Pi]);
0358 whilecnt = 0; alpC = 100*eps;
0359 <span class="keyword">while</span> pC~=0 &amp; whilecnt&lt;100,
0360     whilecnt = whilecnt + 1;
0361     [CC,pC]=chol([Lambda -Omega;-Omega' Pi] + alpC*eye(size(Lambda,1)+size(Pi,1)));
0362     alpC = 2*alpC;
0363 <span class="keyword">end</span>
0364 
0365 <span class="keyword">for</span> i=1:10,
0366     cc=CC*[eye(size(Lambda));G']; 
0367     R=(cc'*cc)/N; 
0368     Ri=pinv(R); 
0369     Ri=(Ri+Ri')/2; 
0370     gnorm = norm(<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(real(Ri*(G*Pi-Omega))));
0371     <span class="keyword">if</span> gnorm &gt; 1e-4, 
0372         HHH=(kron(real(Pi),real(Ri))-kron(imag(Pi)',imag(Ri)));
0373         gg=<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(real(Ri)*real(Omega)-imag(Ri)*imag(Omega)); 
0374         G=reshape(HHH\gg,n,n+m);
0375     <span class="keyword">else</span>
0376         <span class="keyword">break</span>;
0377     <span class="keyword">end</span>
0378 <span class="keyword">end</span>
0379 
0380 <a name="_sub4" href="#_subfunctions" class="code">function [G,i,gnorm] = mincd(N,n,m,p,ejw,G,Phi,Psi,Sigma);</a>
0381 
0382 CC=chol([Phi -Psi;-Psi' Sigma] + 100*eps*eye(size(Phi,1)+size(Sigma,1)));
0383 
0384 <span class="keyword">for</span> i=1:10,
0385     cc=CC*[eye(size(Phi));G']; 
0386     R=(cc'*cc)/N; 
0387     Ri=pinv(R); 
0388     Ri=(Ri+Ri')/2; 
0389     gnorm = norm(<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(real(Ri*(G*Sigma-Psi))));
0390     <span class="keyword">if</span> gnorm &gt; 1e-4, 
0391         HHH=(kron(real(Sigma),real(Ri))-kron(imag(Sigma)',imag(Ri))); 
0392         gg=<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(real(Ri)*real(Psi)-imag(Ri)*imag(Psi)); 
0393         G=reshape(HHH\gg,p,n+m);
0394     <span class="keyword">else</span>
0395         <span class="keyword">break</span>;
0396     <span class="keyword">end</span>
0397 <span class="keyword">end</span>
0398 
0399 
0400 <span class="comment">%----------------------------------------------------------------</span>
0401 <span class="comment">% START of cost ab routine</span>
0402 <span class="comment">%----------------------------------------------------------------</span>
0403 <a name="_sub5" href="#_subfunctions" class="code">function [c,g,H1,H2] = costab(N,n,m,p,ejw,G,Lambda,Omega,Pi);</a>
0404 
0405 <span class="comment">%Depending on whether or not we need derivatives, then compute eigenvectors</span>
0406 <span class="keyword">if</span> nargout&gt;1,
0407  [ve,de]=eig(G(:,1:n));
0408  de=diag(de);
0409 <span class="keyword">else</span>
0410  [de]=eig(G(:,1:n));
0411 <span class="keyword">end</span>
0412 
0413 <span class="comment">%Compute cost</span>
0414 c=<a href="cmpcost.html" class="code" title="function c = cmpcost(ejw,de)">cmpcost</a>(ejw,de);
0415 
0416 MM = [Lambda -Omega;-Omega' Pi];
0417 MM = (MM+MM')/2;
0418 
0419 [CC,pC]=chol(MM);
0420 whilecnt = 0; alpC = 100*eps;
0421 <span class="keyword">while</span> pC~=0 &amp; whilecnt&lt;100,
0422     whilecnt = whilecnt + 1;
0423     [CC,pC]=chol(MM + alpC*eye(size(Lambda,1)+size(Pi,1)));
0424     alpC = 2*alpC;
0425 <span class="keyword">end</span>
0426 <span class="comment">%keyboard</span>
0427 
0428 CC=CC*[eye(size(Lambda));G'];
0429 Q=(CC'*CC)/N;
0430 c=real(c+N*log(det(Q)));
0431 
0432 <span class="comment">%Compute gradient</span>
0433 <span class="keyword">if</span> nargout&gt;1,
0434  nnm     = n*(n+m); 
0435  nn      = n*n;
0436 
0437  <span class="comment">%Compute gradient vector</span>
0438  vei     = ve\speye(size(ve)); 
0439  v1      = <a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(ve,vei.');
0440  [J2,H2] = cmpgh(ejw,de); 
0441  J2      = v1*J2;
0442  g1      = 2*real(<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(pinv(Q)*[G*Pi-Omega]));
0443  g2      = 2*real(J2);
0444  g       = g1;
0445  g(1:nn) = g(1:nn)+2*real(J2);
0446 <span class="keyword">end</span>
0447 
0448 <span class="keyword">if</span> nargout&gt;2,
0449  <span class="comment">%Hack</span>
0450  Qi=Q\speye(n);
0451  Qi=(Qi+Qi')/2;
0452  H1=2*real(<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(Pi.',Qi));
0453 
0454  <span class="comment">%Compute Hessian matrix</span>
0455  v2=<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(vei,ve.');
0456  idx=<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(reshape([1:nnm],n+m,n)');
0457  t1=<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(eye(n),[G*Pi-Omega]);
0458  t2=<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>([G*Pi.'-conj(Omega)],eye(n));
0459  J=(t1(:,idx)+t2)/N;
0460  QikQi=<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(Qi,Qi.');
0461 
0462  scal=H2(:); scal=scal(:,ones(1,nn));
0463  HH=2*real(v1*(scal.*v2));
0464  idx=<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(reshape([1:nn],n,n)');
0465  HH=HH(:,idx);
0466 
0467  H2=-N*real(J.'*QikQi*conj(J));
0468  H2(1:nn,1:nn)=H2(1:nn,1:nn)+HH;
0469 <span class="keyword">end</span>
0470 <span class="comment">%----------------------------------------------------------------</span>
0471 <span class="comment">% END of cost ab routine</span>
0472 <span class="comment">%----------------------------------------------------------------</span>
0473 
0474 <span class="comment">%----------------------------------------------------------------</span>
0475 <span class="comment">% START of cost cd routine</span>
0476 <span class="comment">%----------------------------------------------------------------</span>
0477 <a name="_sub6" href="#_subfunctions" class="code">function [c,g,H1,H2] = costcd(N,n,m,p,ejw,G,Phi,Psi,Sigma);</a>
0478 
0479 <span class="comment">%Compute cost</span>
0480 c=N*real(log(det(Phi-G*Psi' - Psi*G' + G*Sigma*G')));
0481 
0482 <span class="keyword">if</span> nargout&gt;1,
0483  CC=<a href="rchol.html" class="code" title="function [A] = rchol(A);">rchol</a>([Phi -Psi;-Psi' Sigma] + 100*eps*eye(size(Phi,1)+size(Sigma,1)));
0484  CC=CC*[eye(size(Phi));G'];
0485  R=(CC'*CC)/N;
0486  Ri=R\speye(p);
0487  Ri=(Ri+Ri')/2;
0488  gsp=G*Sigma-Psi;
0489  g=2*<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(real(Ri*gsp));
0490 <span class="keyword">end</span>
0491 
0492 <span class="keyword">if</span> nargout&gt;2,
0493  pnm=p*(n+m); idx=<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(reshape([1:pnm],n+m,p)');
0494  t1=<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(eye(p),gsp);
0495  t2=<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(conj(gsp),eye(p));
0496  J=(t1(:,idx)+t2)/N; RikRi=<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(Ri,Ri.');
0497  H1=2*real(<a href="kronaw.html" class="code" title="function c = kronaw(a,b)">kronaw</a>(Sigma.',Ri));
0498  H2=-N*real(J.'*RikRi*conj(J));
0499 <span class="keyword">end</span>
0500 
0501 
0502 <span class="comment">%----------------------------------------------------------------</span>
0503 <span class="comment">% START of argmin routine</span>
0504 <span class="comment">%----------------------------------------------------------------</span>
0505 <a name="_sub7" href="#_subfunctions" class="code">function [G,del,kk,numit,gnorm] = argmin(costfn,N,n,m,p,G,ejw,Phi,Psi,Sigma,opt,del);</a>
0506 
0507 <span class="comment">%Get size of parameter matrix</span>
0508 [nr,nc] = size(G);
0509 
0510 <span class="comment">%Stopping tolerance on Newton decrement</span>
0511 stoptol = opt.stoptol;
0512 
0513 <span class="comment">%Loop through Newton search opt.optit number of times</span>
0514 Ith=eye(length(<a href="vec.html" class="code" title="function x = vec(X)">vec</a>(G))); H=Ith;
0515 <span class="keyword">for</span> numit=1:opt.optit,
0516 
0517  <span class="comment">%Form gradient and Hessian</span>
0518  [cost_old,g,H1,H2] = feval(costfn,N,n,m,p,ejw,G,Phi,Psi,Sigma);
0519  H=H1+H2;
0520  H=real(H+H')/2;
0521 
0522 
0523  <span class="comment">%Use trust region method.</span>
0524  S=eig(H); <span class="keyword">if</span> ~isreal(S), <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'Hessian has complex eigenvalues'</span>,gui,guih); <span class="keyword">end</span>
0525  lam_min=min(0,min(real(S)));
0526 
0527  <span class="keyword">if</span> lam_min &lt; 0, lam=-2*lam_min; <span class="keyword">else</span>, lam_min=0; lam=0; <span class="keyword">end</span>
0528  eta=0.01;
0529 
0530  <span class="keyword">for</span> kk=1:100,
0531   <span class="comment">%Get search direction</span>
0532   [cH,pp]=chol(H+lam*eye(size(H)));
0533   <span class="keyword">while</span> pp~=0,
0534    lam=2*(lam+1e-3);
0535    [cH,pp]=chol(H+(lam+eps)*eye(size(H)));
0536   <span class="keyword">end</span>
0537   dp=-(cH\(cH'\g));
0538 
0539   <span class="comment">%Check that search direction satisfies ||dp|| &lt;= del,</span>
0540   <span class="comment">%if not then find Lagrange multiplier for constrained</span>
0541   <span class="comment">%problem.</span>
0542   i=0;
0543   <span class="keyword">if</span> norm(dp)&gt;del,
0544    hitdel=1;
0545    <span class="keyword">for</span> i=1:100,
0546     q=cH'\dp;
0547     dlam=(norm(dp)/norm(q))^2*((norm(dp)-del)/del);
0548     lam=max(-lam_min,lam+dlam);
0549     [cH,pp]=chol(H+(lam+eps)*eye(size(H)));
0550     <span class="keyword">while</span> pp~=0,
0551      lam=2*(lam+1e-1);
0552      [cH,pp]=chol(H+(lam+eps)*eye(size(H)));
0553     <span class="keyword">end</span>
0554     dp=-cH\(cH'\g);
0555     <span class="keyword">if</span> abs(norm(dp)-del) &lt; 1e-3, <span class="keyword">break</span>; <span class="keyword">end</span>
0556    <span class="keyword">end</span>
0557   <span class="keyword">else</span>
0558    hitdel=0;
0559   <span class="keyword">end</span>
0560 
0561 
0562   <span class="comment">%Check stopping criteria</span>
0563   gnorm=-g'*dp/length(g);
0564   <span class="keyword">if</span> kk&gt;5 &amp;&amp; gnorm &lt; stoptol, <span class="keyword">break</span>; <span class="keyword">end</span>
0565 
0566   <span class="comment">%Get new cost</span>
0567   Gp=reshape(dp,nr,nc); Gn=G+Gp;
0568   cost_new = feval(costfn,N,n,m,p,ejw,Gn,Phi,Psi,Sigma);
0569 
0570   <span class="comment">%Compute actual/predicted cost reduction</span>
0571   rho = (cost_old - cost_new)/(eps-g'*dp-0.5*(dp'*(H*dp + lam*dp)));
0572 
0573   <span class="comment">%Adaptively change trust region according to local</span>
0574   <span class="comment">%performance.</span>
0575   <span class="keyword">if</span> rho &lt; 0.25,
0576    del=0.25*norm(dp);
0577   <span class="keyword">elseif</span> rho &gt; 0.75 &amp; hitdel,
0578    del=min(2*del,1e16);
0579   <span class="keyword">end</span>
0580 
0581   <span class="comment">%If we reduced the cost sufficiently then stop.</span>
0582   <span class="keyword">if</span> rho &gt; eta, G=Gn; <span class="keyword">break</span>; <span class="keyword">end</span>
0583  <span class="keyword">end</span>
0584 
0585  <span class="comment">%Break if we have a sufficiently small Newton decrement</span>
0586  <span class="comment">%gnorm=abs(dp'*g)/length(g);</span>
0587  <span class="keyword">if</span> gnorm &lt; stoptol, <span class="keyword">break</span>; <span class="keyword">end</span>
0588  <span class="keyword">if</span> norm(dp)/norm(G(:)) &lt; 1000*eps, <span class="keyword">break</span>; <span class="keyword">end</span>
0589 <span class="keyword">end</span>
0590 <span class="comment">%----------------------------------------------------------------</span>
0591 <span class="comment">% END of argmin routine</span>
0592 <span class="comment">%----------------------------------------------------------------</span></pre></div>
<hr><address>Generated on Sun 04-May-2025 22:15:31 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>