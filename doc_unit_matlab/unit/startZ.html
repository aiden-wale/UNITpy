<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of startZ</title>
  <meta name="keywords" content="startZ">
  <meta name="description" content="This function accepts a data structure and tries to interpret what type">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">unit</a> &gt; startZ.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for unit&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>startZ
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This function accepts a data structure and tries to interpret what type</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function Z = startZ(Z) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">  This function accepts a data structure and tries to interpret what type
  of data it describes, then fills in blanks where necessary.

  Usage is 

  Z = startZ(Z);
 
  where:

   Z:          Can represent time or frequency domain data as follows.

   Z.type:     Can be 'time' or 'frequency' and will be used to interpret
               the data in Z. Default is Z.type='time', but will be set
               depending on Z.y below.

   TIME:    
      Z.y:     A matrix containing the output data.  The number of rows
               is equal to the number of data samples, and the number of 
               columns is equal to the number of outputs. This must be
               supplied.

      Z.u:     A matrix containing the input data.  The number of rows
               is equal to the number of data samples, and the number of 
               columns is equal to the number of input.

      Z.t:     A vector containing the sample times (can be
               non-equidistant). Default Z.t=0:Z.T:(N-1)*Z.T, where
               N=number of samples.
    
      Z.T:     Positive number represting the sample interval. Z.T is zero
               for non-equidistant data. Default is Z.T=1;

      Z.D:     Positive number represting the integrated sampling time. 
               Z.D must be no greater than Z.T. Z.D is zero
               for non-equidistant data. Default is Z.D=Z.T;

      Z.d:     A vector (of the same length as Z.t) corresponding to the 
               integration time for sampled continuous-time signals. 
               Z.d = min(diff(Z.t))*ones(1,N); by default.



   FREQUENCY:
      Z.y:     A complex valued 3D-matrix containing the output data.  The
               first two dimensions are equal to the number of outputs and
               inputs, respectively. The third dimension is equal to the  
               number of data samples. This must be supplied.

      Z.u:     A complex valued 3D-matrix containing the input data.  The
               first two dimensions are equal to the number of outputs and
               inputs, respectively. The third dimension is equal to the  
               number of data samples. If not supplied, it is assumed that
               Z.y represents Frequency Response Functions, for which 
               Z.u(:,:,k) = I.

      Z.w:     A vector containing the frequency points corresponding to
               samples (can be non-equidistant). If Z.w(.) &gt; 2*pi, then
               Z.discrete will be set to zero. Z.w must be supplied.
    
      Z.T:     Positive number represting the sample interval. Z.T is zero
               for continuous data. Default is Z.T=1;




   written by Brett Ninness, School of EE &amp; CS
              Adrian Wills   University of Newcastle
                             Australia.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="Z2data.html" class="code" title="function [y,u,ny,nu,Ny,Z] = Z2data(Z)">Z2data</a>	Z2DATA: Takes structure defining input-output data and extracts that</li><li><a href="argmin.html" class="code" title="function [theta,cost_log,ARGS] = argmin(Z,FUN,theta,OPT,ARGS,fargs)">argmin</a>	Function to find minimum of function that is defined by user supplied</li><li><a href="checkZM.html" class="code" title="function [flag,message] = checkZM(Z,M)">checkZM</a>	</li><li><a href="demo_farx.html" class="code" title="">demo_farx</a>	Running this tests estimation of ARX model structure from frequency</li><li><a href="demo_foe.html" class="code" title="">demo_foe</a>	Running this demos LS estimation of Output-Error model from frequency</li><li><a href="demo_nlss.html" class="code" title="">demo_nlss</a>	Running this demos estimation of a general nonlinear</li><li><a href="est.html" class="code" title="function G = est(Z,M,OPT)">est</a>	EST: Computes an estimate of either a Box-Jenkins model or a state space</li><li><a href="fem.html" class="code" title="function g = fem(z,mm,opt);">fem</a>	This function tries to compute the maximum likelihood estimate of a</li><li><a href="fir.html" class="code" title="function G = fir(Z,M,OPT)">fir</a>	This function does least squares fitting for FIR models based on</li><li><a href="fsid.html" class="code" title="function [g] = fsid(z,mm,OPT)">fsid</a>	FSID computes a state space model [A,B,C,D] that fits an observed (possibly</li><li><a href="m2f.html" class="code" title="function G = m2f(M);">m2f</a>	M2F - function to compute the frequency response of a linear time</li><li><a href="nonpar.html" class="code" title="function G = nonpar(Z,M,OPT);">nonpar</a>	NONPAR This routine takes a record of input-output data [y,u] and</li><li><a href="onid.html" class="code" title="function G = onid(Z,M,OPT)">onid</a>	This function does least squares fitting with respect to orthogonal</li><li><a href="sir.html" class="code" title="function G = sir(Z,M,OPT);">sir</a>	SIR.  This function implements a Sequential Importance Resampler (SIR),</li><li><a href="sirs.html" class="code" title="function G = sirs(Z,M,OPT);">sirs</a>	SIRS.  This function implements a Sequential Importance Resampling Smoother (SIRS),</li><li><a href="startG.html" class="code" title="function M = startG(Z,M,OPT)">startG</a>	STARTG - function to initialise estimate of dynamics model in case user</li><li><a href="startM.html" class="code" title="function M = startM(varargin)">startM</a>	STARTM - function to initialise a model structure in case user has been</li><li><a href="subspace.html" class="code" title="function G = subspace(Z,M,OPT)">subspace</a>	Function that calls underlying subspace algorithms depending on data</li><li><a href="validate.html" class="code" title="function [handle, cost, pe] = validate(varargin)">validate</a>	This function is used to compare the predictive performance of an</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%  This function accepts a data structure and tries to interpret what type</span>
0002 <span class="comment">%  of data it describes, then fills in blanks where necessary.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%  Usage is</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%  Z = startZ(Z);</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%  where:</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%   Z:          Can represent time or frequency domain data as follows.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%   Z.type:     Can be 'time' or 'frequency' and will be used to interpret</span>
0013 <span class="comment">%               the data in Z. Default is Z.type='time', but will be set</span>
0014 <span class="comment">%               depending on Z.y below.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   TIME:</span>
0017 <span class="comment">%      Z.y:     A matrix containing the output data.  The number of rows</span>
0018 <span class="comment">%               is equal to the number of data samples, and the number of</span>
0019 <span class="comment">%               columns is equal to the number of outputs. This must be</span>
0020 <span class="comment">%               supplied.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%      Z.u:     A matrix containing the input data.  The number of rows</span>
0023 <span class="comment">%               is equal to the number of data samples, and the number of</span>
0024 <span class="comment">%               columns is equal to the number of input.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%      Z.t:     A vector containing the sample times (can be</span>
0027 <span class="comment">%               non-equidistant). Default Z.t=0:Z.T:(N-1)*Z.T, where</span>
0028 <span class="comment">%               N=number of samples.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%      Z.T:     Positive number represting the sample interval. Z.T is zero</span>
0031 <span class="comment">%               for non-equidistant data. Default is Z.T=1;</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%      Z.D:     Positive number represting the integrated sampling time.</span>
0034 <span class="comment">%               Z.D must be no greater than Z.T. Z.D is zero</span>
0035 <span class="comment">%               for non-equidistant data. Default is Z.D=Z.T;</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%      Z.d:     A vector (of the same length as Z.t) corresponding to the</span>
0038 <span class="comment">%               integration time for sampled continuous-time signals.</span>
0039 <span class="comment">%               Z.d = min(diff(Z.t))*ones(1,N); by default.</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%   FREQUENCY:</span>
0044 <span class="comment">%      Z.y:     A complex valued 3D-matrix containing the output data.  The</span>
0045 <span class="comment">%               first two dimensions are equal to the number of outputs and</span>
0046 <span class="comment">%               inputs, respectively. The third dimension is equal to the</span>
0047 <span class="comment">%               number of data samples. This must be supplied.</span>
0048 <span class="comment">%</span>
0049 <span class="comment">%      Z.u:     A complex valued 3D-matrix containing the input data.  The</span>
0050 <span class="comment">%               first two dimensions are equal to the number of outputs and</span>
0051 <span class="comment">%               inputs, respectively. The third dimension is equal to the</span>
0052 <span class="comment">%               number of data samples. If not supplied, it is assumed that</span>
0053 <span class="comment">%               Z.y represents Frequency Response Functions, for which</span>
0054 <span class="comment">%               Z.u(:,:,k) = I.</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%      Z.w:     A vector containing the frequency points corresponding to</span>
0057 <span class="comment">%               samples (can be non-equidistant). If Z.w(.) &gt; 2*pi, then</span>
0058 <span class="comment">%               Z.discrete will be set to zero. Z.w must be supplied.</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%      Z.T:     Positive number represting the sample interval. Z.T is zero</span>
0061 <span class="comment">%               for continuous data. Default is Z.T=1;</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%</span>
0064 <span class="comment">%</span>
0065 <span class="comment">%</span>
0066 <span class="comment">%   written by Brett Ninness, School of EE &amp; CS</span>
0067 <span class="comment">%              Adrian Wills   University of Newcastle</span>
0068 <span class="comment">%                             Australia.</span>
0069 
0070 <span class="comment">% Copyright (C) Brett Ninness.</span>
0071 
0072 <a name="_sub0" href="#_subfunctions" class="code">function Z = startZ(Z)</a>
0073 
0074 <span class="comment">% Do we have any data?</span>
0075 <span class="keyword">if</span> nargin&lt;1,
0076  error(<span class="string">'No data structure supplied'</span>);
0077 <span class="keyword">end</span>
0078 
0079 <span class="comment">% Try for a quick return</span>
0080 <span class="keyword">if</span> isfield(Z,<span class="string">'passed_startZ'</span>),
0081  <span class="keyword">return</span>;
0082 <span class="keyword">end</span>
0083 
0084 <span class="comment">%OK, if passed an empty Z, then fill it in</span>
0085 <span class="keyword">if</span> isempty(Z),
0086  Z.u = 0;
0087  Z.y = 0;
0088 <span class="keyword">end</span>
0089  
0090 
0091 <span class="comment">% Determine if Z is a structure or a matrix</span>
0092 <span class="keyword">if</span> isstruct(Z),
0093  <span class="comment">% Do we have a Z.y? - MUST have this.</span>
0094  <span class="keyword">if</span> ~isfield(Z,<span class="string">'y'</span>),
0095   error(<span class="string">'Must have a Z.y field'</span>);
0096  <span class="keyword">end</span>
0097 <span class="keyword">else</span> <span class="comment">% Else Z is just a matrix so make it a structure</span>
0098  [N,nin] = size(Z); 
0099  <span class="keyword">if</span> N&lt;nin, 
0100   Z=Z.'; 
0101   [N,nin] = size(Z); 
0102  <span class="keyword">end</span>
0103  Zm = Z; 
0104  Z  = struct;
0105  y  = Zm(:,1);  
0106  <span class="keyword">if</span> nin&gt;1,
0107   <span class="keyword">if</span> isreal(y),
0108    Z.y = y;
0109    Z.u = Zm(:,2:nin);
0110   <span class="keyword">else</span>
0111    Z.y(1,1,:) = y;
0112    Z.w = Zm(:,2);
0113   <span class="keyword">end</span>
0114  <span class="keyword">else</span>
0115   <span class="keyword">if</span> isreal(y),
0116    Z.y = y;
0117   <span class="keyword">else</span>
0118    error(<span class="string">'First column of data is complex valued, but there is no second column (frequency).'</span>);
0119   <span class="keyword">end</span>
0120  <span class="keyword">end</span>
0121 <span class="keyword">end</span>
0122 
0123 <span class="comment">% Is there any data in Z.y?</span>
0124 <span class="keyword">if</span> prod(size(Z.y))==0,
0125  error(<span class="string">'One or more dimsensions of Z.y is 0. Must have data to proceed.'</span>);
0126 <span class="keyword">end</span>
0127 
0128 <span class="comment">% Determine type of data (time or frequency)?</span>
0129 <span class="comment">%Z.type</span>
0130 <span class="keyword">if</span> ~isfield(Z,<span class="string">'type'</span>),
0131  <span class="keyword">if</span> isreal(Z.y), 
0132   Z.type=<span class="string">'time'</span>; 
0133     <span class="keyword">else</span>
0134   Z.type=<span class="string">'frequency'</span>; 
0135  <span class="keyword">end</span>
0136 <span class="keyword">else</span>
0137  <span class="keyword">switch</span> Z.type,
0138   <span class="keyword">case</span> <span class="string">'time'</span>,
0139    <span class="keyword">if</span> ~isreal(Z.y), 
0140                 error(<span class="string">'startZ:typeInconsistentReal'</span>, <span class="string">'Z.type is inconsistent with Z.y (Z.y should be real valued).'</span>);
0141             <span class="keyword">end</span>
0142   <span class="keyword">case</span> <span class="string">'frequency'</span>,
0143    <span class="keyword">if</span> isreal(Z.y), 
0144     error(<span class="string">'startZ:typeInconsistentComplex'</span>, <span class="string">'Z.type is inconsistent with Z.y (Z.y should be complex valued).'</span>); 
0145    <span class="keyword">end</span>
0146   <span class="keyword">otherwise</span>,
0147    error(<span class="string">'The value in Z.type is not known.'</span>);
0148  <span class="keyword">end</span>
0149 <span class="keyword">end</span>
0150 
0151 <span class="comment">% Now determine missing bits and other things depending on Z.type</span>
0152 <span class="keyword">switch</span> Z.type,
0153 
0154 <span class="comment">%--------------------------------------------------------------------------</span>
0155 <span class="comment">%   TIME DOMAIN DATA</span>
0156 <span class="comment">%--------------------------------------------------------------------------</span>
0157  <span class="keyword">case</span> <span class="string">'time'</span>,
0158   <span class="comment">% Get output data dimensions and rotate if necessary</span>
0159   [Ny,p]=size(Z.y); 
0160   <span class="keyword">if</span> p&gt;Ny, Z.y=Z.y.'; <span class="keyword">end</span>
0161   [Ny,p]=size(Z.y);
0162   Z.Ny=Ny; 
0163   Z.ny=p;
0164   Z.nu=0; <span class="comment">%Changed if necessary soon...</span>
0165   
0166   <span class="keyword">if</span> isfield(Z,<span class="string">'u'</span>),
0167    <span class="comment">% Get input data dimensions</span>
0168    [Nu,m]=size(Z.u);
0169    <span class="keyword">if</span> Nu*m==0,
0170     Z.u = [];
0171    <span class="keyword">else</span>
0172     <span class="keyword">if</span> m&gt;Nu, Z.u=Z.u.'; <span class="keyword">end</span>
0173     [Nu,m]=size(Z.u);
0174     Z.nu=m;
0175     <span class="comment">% Chack that number of input samples equals number of output</span>
0176     <span class="comment">% samples</span>
0177     <span class="keyword">if</span> Nu~=Ny,
0178      error(<span class="string">'Number of input samples does NOT equal number of output samples!'</span>);
0179     <span class="keyword">end</span>
0180    <span class="keyword">end</span>
0181   <span class="keyword">else</span>,
0182    Z.u=[];
0183   <span class="keyword">end</span>
0184   
0185   <span class="keyword">if</span> isfield(Z,<span class="string">'T'</span>),
0186    <span class="keyword">if</span> Z.T&gt;0, <span class="comment">% Data should be discrete</span>
0187     <span class="keyword">if</span> isfield(Z,<span class="string">'t'</span>),
0188      <span class="comment">% Make sure t is equidistant</span>
0189      <span class="keyword">if</span> (abs(max(diff(Z.t)) - min( diff(Z.t))) &gt; 1e-10),
0190       error(<span class="string">'Z.t is not equidistant, but Z.T&gt;0.'</span>)
0191      <span class="keyword">end</span>
0192     <span class="keyword">else</span>
0193      Z.t=0:Z.T:(Ny-1)*Z.T;
0194     <span class="keyword">end</span>
0195    <span class="keyword">else</span> <span class="comment">% Data should be continuous</span>
0196     <span class="keyword">if</span> ~isfield(Z,<span class="string">'t'</span>),
0197      error(<span class="string">'Time stamps Z.t must be supplied for non-equidistant data (i.e. if Z.T=0).'</span>);
0198     <span class="keyword">end</span>
0199    <span class="keyword">end</span>
0200    
0201   <span class="keyword">else</span> <span class="comment">% No Z.T field, so try and decide</span>
0202    <span class="keyword">if</span> isfield(Z,<span class="string">'t'</span>),
0203     <span class="keyword">if</span> max(diff(Z.t))-min(diff(Z.t)) &gt; 1e-12,
0204      Z.T=0;
0205     <span class="keyword">else</span>
0206      Z.T=mean(diff(Z.t));
0207     <span class="keyword">end</span>
0208    <span class="keyword">else</span>,
0209     Z.T=1;
0210     Z.t=0:Z.T:(Ny-1)*Z.T;
0211    <span class="keyword">end</span>
0212   <span class="keyword">end</span>
0213    
0214   <span class="keyword">if</span> ~isfield(Z,<span class="string">'D'</span>),
0215    Z.D = Z.T;
0216   <span class="keyword">end</span>
0217   
0218   <span class="keyword">if</span> isfield(Z,<span class="string">'d'</span>),
0219    <span class="keyword">if</span> max(d) &gt; min(diff(Z.t)),
0220     error(<span class="string">'An integration time in Z.d is greater than the time between samples in Z.t!'</span>);
0221    <span class="keyword">elseif</span> length(Z.d)&gt;1 &amp; length(Z.d)&lt;N,
0222     error(<span class="string">'Must have the same number of entries in integration times Z.d as there are samples!'</span>)
0223    <span class="keyword">elseif</span> length(Z.d)==1,
0224     Z.d = Z.d*ones(1,Z.Ny);
0225    <span class="keyword">end</span>
0226   <span class="keyword">else</span>
0227    Z.d = min(diff(Z.t))*ones(1,Z.Ny);
0228   <span class="keyword">end</span>
0229   
0230   
0231 <span class="comment">%--------------------------------------------------------------------------</span>
0232 <span class="comment">%   FREQUENCY DOMAIN DATA</span>
0233 <span class="comment">%--------------------------------------------------------------------------</span>
0234  <span class="keyword">case</span> <span class="string">'frequency'</span>
0235   <span class="comment">% Help user in case of SISO data - it's not natural to make a 3 dim array for a vector</span>
0236   <span class="keyword">if</span> (ndims(Z.y)&lt;3)
0237    [M, N] = size(Z.y);
0238    <span class="keyword">if</span> M &gt; N, 
0239     Z.y = Z.y.';
0240    <span class="keyword">end</span>
0241    [M, N] = size(Z.y);
0242    <span class="keyword">if</span>(M &lt; 2)
0243     y(1,1,:) = Z.y;
0244     Z=rmfield(Z,<span class="string">'y'</span>);
0245     Z.y=y;
0246    <span class="keyword">else</span>
0247     error(<span class="string">'startZ:lackOfDimensions'</span>, <span class="string">'Z.y does not have enough  dimensions.'</span>);
0248    <span class="keyword">end</span>
0249   <span class="keyword">end</span>
0250         <span class="comment">% Get output data dimensions and rotate if necessary</span>
0251   [p,m,Ny]=size(Z.y); 
0252   <span class="keyword">if</span> p&gt;Ny | m&gt;Ny, 
0253    error(<span class="string">'Z.y needs to be transposed (see help startZ).'</span>);
0254   <span class="keyword">end</span>
0255   Z.Ny = Ny;
0256   Z.ny = p;
0257   Z.nu = m;
0258   
0259   <span class="comment">%Check for input data (default to Z.u(:,:,k) = I if not).</span>
0260   <span class="keyword">if</span> isfield(Z,<span class="string">'u'</span>),
0261    <span class="comment">% Help user in case of SISO data - it's not natural to make a 3</span>
0262    <span class="comment">% dim array for a vector</span>
0263    <span class="keyword">if</span> (ndims(Z.u)&lt;3)
0264     [M, N] = size(Z.u);
0265     <span class="keyword">if</span> M &gt; N,
0266      Z.u = Z.u.';
0267     <span class="keyword">end</span>
0268     [M, N] = size(Z.u);
0269     <span class="keyword">if</span>(M &lt; 2)
0270      u(1,1,:) = Z.u;
0271      Z=rmfield(Z,<span class="string">'u'</span>);
0272      Z.u=u;
0273     <span class="keyword">else</span>
0274      <span class="comment">%Assume a multi-input signal that is given as a m x N</span>
0275      <span class="comment">%matrix</span>
0276      u(:,1,:) = Z.u;
0277      Z=rmfield(Z,<span class="string">'u'</span>);
0278      Z.u=u;
0279     <span class="keyword">end</span>
0280    <span class="keyword">end</span>
0281   <span class="keyword">else</span>
0282    Z.u = zeros(Z.ny,Z.nu,Z.Ny);
0283    <span class="keyword">for</span> k=1:Z.Ny,
0284     Z.u(:,:,k) = eye(Z.ny,Z.nu);
0285    <span class="keyword">end</span>
0286   <span class="keyword">end</span>
0287   
0288   <span class="keyword">if</span> ~isfield(Z,<span class="string">'w'</span>),
0289    error(<span class="string">'Frequency domain data requires a Z.w field.'</span>);
0290   <span class="keyword">else</span> <span class="comment">% There is an omega</span>
0291     <span class="keyword">if</span> max(abs(Z.w))&gt;pi, <span class="comment">% Continuous model required?</span>
0292      <span class="keyword">if</span> isfield(Z,<span class="string">'T'</span>),
0293       <span class="keyword">if</span> max(abs(Z.w))&gt;pi/Z.T+sqrt(eps),
0294        warning(<span class="string">'Frequency range is greater than expected, i.e. max(abs(Z.w)) &gt; pi/Z.T.'</span>);
0295       <span class="keyword">end</span>
0296     <span class="keyword">else</span>
0297       Z.T=0;
0298      <span class="keyword">end</span>
0299     <span class="keyword">else</span> <span class="comment">% Should be discrete</span>
0300      <span class="keyword">if</span> ~isfield(Z,<span class="string">'T'</span>),
0301       Z.T=1;
0302      <span class="keyword">end</span>
0303     <span class="keyword">end</span>
0304   <span class="keyword">end</span>
0305 
0306 <span class="comment">%--------------------------------------------------------------------------</span>
0307 <span class="comment">%   OTHERWISE DATA FORMAT NOT KNOWN</span>
0308 <span class="comment">%--------------------------------------------------------------------------</span>
0309  <span class="keyword">otherwise</span>,
0310   error(<span class="string">'Value in Z.type is not known.'</span>);
0311 <span class="keyword">end</span>
0312 
0313 Z.passed_startZ=1;</pre></div>
<hr><address>Generated on Sun 04-May-2025 22:15:31 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>