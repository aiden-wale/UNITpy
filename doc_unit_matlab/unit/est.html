<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of est</title>
  <meta name="keywords" content="est">
  <meta name="description" content="EST: Computes an estimate of either a Box-Jenkins model or a state space">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">unit</a> &gt; est.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for unit&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>est
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>EST: Computes an estimate of either a Box-Jenkins model or a state space</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function G = est(Z,M,OPT) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">  EST: Computes an estimate of either a Box-Jenkins model or a state space
  model.  In the Box--Jenkins case the structure is of the form

          B(p)                   C(p)
  y_t  =  ---- u_{t-delay}   +   ---- e_t
          A(q)                   D(p)

  where e_t is white noise, p can be the forward shift operator q or
  the Euler differencing (delta) operator d = (q-1)/T (with T being
  the sampling period) and a quadratic (least squares) prediction error
  loss criterion is used.  A(p) through D(p) are all polynomials in p of
  the form

  A(p) = 1.0 + a_1 p^{-1} + a_2 p^{-2} + ... + a_n p^{-n}
  B(p) = b_0 + b_1 p^{-1} + b_2 p^{-2} + ... + b_m p^{-m}
  C(p) = 1.0 + c_1 p^{-1} + c_2 p^{-2} + ... + c_r p^{-r}
  D(p) = 1.0 + d_1 p^{-1} + d_2 p^{-2} + ... + d_r p^{-r}

  This is the SISO linear form, but MISO forms and inclusion of
  Hammerstein and Wiener non-linearity blocks are also supported.

  In the state space case, the model is of the form

  px_t = Ax_t + Bu_t + F(x_t \otimes u_t) + w_t
   y_t = Cx_t + Du_t + G(x_t \otimes u_t) + e_t

  with w_t and e_t being state and measurement noise.  In the purely
  linear modelling case, F and G are set to zero, but otherwise a
  bilinear model is estimated.

  Usage is

  G = est(Z,M,OPT);

  where:

   Z:          Input-Output data in one of two forms.  The standard form
               is for it to be a record with elements Z.y and Z.u, each
               of which are matrices with number of rows equal to the
               number of data samples, and number of columns equal (respectively)
               to the number of outputs and the number of inputs.  On
               the other hand, Z can be a matrix of the form Z = [y,u]
               where it is assumed that y is a column vector of output
               measurements and u is a matrix whose columns are the
               input measurements; in this latter MISO models are
               being considered.

               In Addition, both non-equidistant time domain data, and
               frequency domain data can also be supplied via Z. Please
               type &quot;help startZ&quot; at the command prompt for further
               details.


  M:           Data structure which defines the model structure which
               is to be estimated from the data as follows:
    M.A,M.B:   Initial guess for input-output dynamics.  If these are
               given as integers, then they are interpreted as
               specifications of the numbers of zeros in M.A and M.B.
               Each row of M.A or M.B specifies initiation of on i/o
               component of possible MISO model.  Any poly spec is
               interpreted in *decreasing* powers of p, starting at
               zeroth power.  Pad with trailing zeros if necessary to
               make all rows of same length.
    M.C,M.D:   Initial guess for measurement noise model.  If not
               specified, or specified as empty matrices, then
               the default is C/D 1; If M.C and M.D are specified as
                     integers, then this is interpreted as the number of poles
                     and zeros to be estimated in C and D.
    M.delay:   Number of samples of delay to include (see above model).
               In the case of a MISO system, this should be a vector of
               delays, one for each input being considered.  Default is
               delays are all equal to zero.
    M.op:      Set to 'q' for shift and 'd' for delta.  Default = 'q'.
    M.T:       Sampling period in s. (Ignored for q case) Default = 1;
    M.w:       Vector of frequencies at which to calculate frequency
               response of estimated model.  Specify in real frequency,
               not normalised.  Default is 3 decades up to folding freq.
    M.type:    Type of model structure for linear dynamics estimation.
               Valid types are: 'arma','fir','arx','armax','oe','bj' for
               polynomial models, 'ss' for a linear state space model,
               and 'bilinear' for a bilinear state space model.
               If M.type is not specified, it is guessed from how
               M.A,M.B, M.C and M.D are specified.
    M.in(k):   Structure that defines any static non-linearities on the
               k'th input. This structure contains an element M.in(k).type
               whose default value is `linear', but may be set to the
               following other values in which case other elements of
               M.in(k) (as indicated) may also be set:
M.in(k).type:  'poly'.  This fits a polynomial model to the input
               non-linearity, in which case M.in.eta specifies either
               (if a single integer) the order of the polynomial or (if
               a vector) an initial guess at the terms in the
               polynomial.  If M.in.eta is not specified, then a default
               cubic model is used.
M.in(k).type:  'hinge'.  This fits a `hinging hyperplane' (ie. peicewise
               linear) model to the input non-linearity. In which case
               M.in.eta specifies the piecewise linearity in a fashion
               impossible to document quickly here.  The default is a
               deadzone shape non-linearity.
       M.par:  Specification of state-space parametrisation used in
               Gauss--Newton algorithm. This may be one of:
               'ddlc' : Data-Driven-Local-Coordinates - default for
                        state-space models (both linear and bilinear).
               'full' : Full parametrisation.
  OPT:         Data structure which defines options for the estimation
               algorithm as follows:
    OPT.alg:   Specification of estimation algorithm to use.  This may
               be one of:
               'gn' : Gradient based search via damped Gauss--Newton
                      algorithm - default for SISO or MISO models.
               'em' : Maximum likelihood estimation via EM algorithm
                      iterative search - default for MIMO models.
    'n4sid' or 'sid': N4SID Subspace based system identification method.
               'cca': Canonical Correlation Analysis method.

                The default is OPT.alg='gn' for SISO and MISO systems,
                but OPT.alg='em' as a default for MIMO systems.
    OPT.dir:   Search direction for gradient based search method, can be
               'rgn' for robust Gauss-Newton, 'lm' for
               Levenberg-Marquardt, 'trust' for trust region, 'bfgs' for
               quasi-Newton method, 'grad' for pure gradient search.
    OPT.cost:  Can be 'trace' to minimise trace of sum of squared errors,
               or 'det' to minimise the log determinant of the sum of
               outer product of error vectos (related to Maximum-Likelihood)
    OPT.dsp:   Optional, set to something non-zero for verbose output.
               Default is OPT.dsp=0;
    OPT.n:     Number of starting data points to discard to get
               rid of initial condition effects.  Default is none.
    OPT.delta: Regularisation value for Levenberg-Marquardt and Trust
               region search methods.
    OPT.step:  Number of prediction samples ahead to use in cost
               criterion - only applies for OPT.alg='gn'.  Default is OPT.step=1;
    OPT.miter: Maximum number of updates of estimate from initial guess.
               Default is 200.
    OPT.tol:   If normalised gradient is less than OPT.tol, then gn
               algorithm will terminate
    OPT.lmax:  Maximum number of times search distance will be shortened
               by bisection.  Default is 52.
    OPT.mdec:  Minimum relative decrease of cost before search is
               terminated.  Default is 1e-9;
    OPT.fast:  When set to 1, then makes algorithm run maximally fast by
               avoiding the calculation of error bounds.  Default is 0.

  G:           Data structure which specifies the estimated model as
               follows:
 G.A, G.B:     Matrices definining the estimated transfer function model.
 G.C, G.D:     For SISO systems, these element are row vectors defining
               co-efficients of increasing powers of M.op^-1.  For MISO,
               they are matrices of rows, the k't row pertaining to the
               k'th input.  For MIMO, they are 3 dim matrices with the
               row (k,:,m) defining the transfer function from the k'th
               input to the m'th output.
 G.ss.A,B,C:   [A,B,C,D,F,G] matrices/vectors defining estimated model in
      D,F,G:   state space form.
 G.ss.X0,P0:   EM algorithm case only - estimate of ic's;
    G.G:       Matrix of frequency responses.  If the system has multiple
               inputs and multiple outputs, then this matrix is 3
               dimensional, with one `page' per output, and the i'th
               column of the j'th page (ie G.G(:,i,j)) being the
               frequency response from input i to ouput j.
    G.H:       Frequency response of estimated spectral factor of
               measurement noise - may be multivariable as above.
    G.Ge:      Matrix specifying 95% confidence regions for estimated
               frequency response Ghat.  They may be plotted by using either
               of the commands `shownyq(G)' or `showbode(G)'.
    G.Gvar:    Vector which is var(G(w)), one element per element in G.w.
    G.P:       Covariance Matrix for Estimated Parameters.
    G.th:      Parameter estimates as a column vector.
    G.mse:     Evolution of mean square cost decrease as any iterative
               algorithm (em, gn) progresses;
    G.LL:      EM algorithm only - evolution of log likelihood increase.

   written by Brett Ninness, School of EE &amp; CS
              Adrian Wills   University of Newcastle
                               Australia.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="estmap.html" class="code" title="function ep = estmap(Z,M,OPT);">estmap</a>	This function provides a mapping from Model type (M.type) and Data type</li><li><a href="startM.html" class="code" title="function M = startM(varargin)">startM</a>	STARTM - function to initialise a model structure in case user has been</li><li><a href="startOPT.html" class="code" title="function OPT = startOPT(OPTin,Min)">startOPT</a>	STARTOPT - function to initialise estimation options in case user has been</li><li><a href="startZ.html" class="code" title="function Z = startZ(Z)">startZ</a>	This function accepts a data structure and tries to interpret what type</li><li><a href="subspace.html" class="code" title="function G = subspace(Z,M,OPT)">subspace</a>	Function that calls underlying subspace algorithms depending on data</li><li><a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="demo_ar.html" class="code" title="">demo_ar</a>	Running this demos estimation of AR model structure</li><li><a href="demo_arma.html" class="code" title="">demo_arma</a>	Running this demos estimation of ARMA model structure</li><li><a href="demo_armax.html" class="code" title="">demo_armax</a>	Running this demos estimation of ARMAX model</li><li><a href="demo_arx.html" class="code" title="">demo_arx</a>	Running this demos estimation of ARX model structure</li><li><a href="demo_bilin.html" class="code" title="">demo_bilin</a>	Running this demos estimation of multivariable bilinear system</li><li><a href="demo_bilin_rand.html" class="code" title="">demo_bilin_rand</a>	Running this tests estimation of randomly chosen 8'th order</li><li><a href="demo_bj.html" class="code" title="">demo_bj</a>	Running this tests PEM estimation of Box-Jenkins model structure</li><li><a href="demo_farx.html" class="code" title="">demo_farx</a>	Running this tests estimation of ARX model structure from frequency</li><li><a href="demo_fir.html" class="code" title="">demo_fir</a>	Running this demos least squares estimation</li><li><a href="demo_foe.html" class="code" title="">demo_foe</a>	Running this demos LS estimation of Output-Error model from frequency</li><li><a href="demo_hammer.html" class="code" title="">demo_hammer</a>	Running this demos PEM estimation of Hammerstein model structure</li><li><a href="demo_hammwiener.html" class="code" title="">demo_hammwiener</a>	Running this demos PEM estimatin of Hammerstein-Weiner Model Structure</li><li><a href="demo_mcmc.html" class="code" title="">demo_mcmc</a>	</li><li><a href="demo_memoryless.html" class="code" title="">demo_memoryless</a>	Running this demos estimation of a static (memoryless)</li><li><a href="demo_mimo.html" class="code" title="">demo_mimo</a>	Running this demo's ML estimation of MIMO system via GN-based</li><li><a href="demo_mimo_ct.html" class="code" title="">demo_mimo_ct</a>	Running this demo's PEM estimation of continuous time state space</li><li><a href="demo_mimo_freq.html" class="code" title="">demo_mimo_freq</a>	Running this demo's ML estimation of MIMO systems from frequency</li><li><a href="demo_mimo_rand.html" class="code" title="">demo_mimo_rand</a>	Running this demos EM estimation of a randomly chosen multivariable</li><li><a href="demo_miso.html" class="code" title="">demo_miso</a>	Running this demos MISO linear system estimation</li><li><a href="demo_miso_hammer.html" class="code" title="">demo_miso_hammer</a>	Running this demos MISO Hammerstein system estimation</li><li><a href="demo_miso_hammwiener.html" class="code" title="">demo_miso_hammwiener</a>	Running this demos estimation of MISO Hammerstein-Wiener</li><li><a href="demo_mtseries.html" class="code" title="">demo_mtseries</a>	Running this demos the estimation of a multivariable</li><li><a href="demo_nlss.html" class="code" title="">demo_nlss</a>	Running this demos estimation of a general nonlinear</li><li><a href="demo_nonpar.html" class="code" title="">demo_nonpar</a>	Running this demos non-parametric estimation algorithms</li><li><a href="demo_oe.html" class="code" title="">demo_oe</a>	Running this demos PEM estimation of Output-Error model structure</li><li><a href="demo_recarx.html" class="code" title="">demo_recarx</a>	Running this demos estimation of ARX model structure</li><li><a href="demo_recfir.html" class="code" title="">demo_recfir</a>	Running this demos estimation of FIR model structure</li><li><a href="demo_sid.html" class="code" title="">demo_sid</a>	Running this demos estimation of state space model</li><li><a href="demo_struct.html" class="code" title="">demo_struct</a>	Running this demo's ML estimation of grey-box parametrized MIMO model</li><li><a href="demo_tfcts.html" class="code" title="">demo_tfcts</a>	Running this demo's estimation of continuous time</li><li><a href="demo_wiener.html" class="code" title="">demo_wiener</a>	Running this demos estimation of Weiner Model</li><li><a href="em_hamm.html" class="code" title="function G=em_hamm(Z,M,OPT);">em_hamm</a>	Extract sizes of input and output from data matrix</li><li><a href="postdist.html" class="code" title="function G = postdist(Z,M,OPT)">postdist</a>	POSTDIST: Compute the posterior distribution marginals p(theta_k|y) of parameters</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%  EST: Computes an estimate of either a Box-Jenkins model or a state space</span>
0002 <span class="comment">%  model.  In the Box--Jenkins case the structure is of the form</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%          B(p)                   C(p)</span>
0005 <span class="comment">%  y_t  =  ---- u_{t-delay}   +   ---- e_t</span>
0006 <span class="comment">%          A(q)                   D(p)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%  where e_t is white noise, p can be the forward shift operator q or</span>
0009 <span class="comment">%  the Euler differencing (delta) operator d = (q-1)/T (with T being</span>
0010 <span class="comment">%  the sampling period) and a quadratic (least squares) prediction error</span>
0011 <span class="comment">%  loss criterion is used.  A(p) through D(p) are all polynomials in p of</span>
0012 <span class="comment">%  the form</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%  A(p) = 1.0 + a_1 p^{-1} + a_2 p^{-2} + ... + a_n p^{-n}</span>
0015 <span class="comment">%  B(p) = b_0 + b_1 p^{-1} + b_2 p^{-2} + ... + b_m p^{-m}</span>
0016 <span class="comment">%  C(p) = 1.0 + c_1 p^{-1} + c_2 p^{-2} + ... + c_r p^{-r}</span>
0017 <span class="comment">%  D(p) = 1.0 + d_1 p^{-1} + d_2 p^{-2} + ... + d_r p^{-r}</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%  This is the SISO linear form, but MISO forms and inclusion of</span>
0020 <span class="comment">%  Hammerstein and Wiener non-linearity blocks are also supported.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%  In the state space case, the model is of the form</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%  px_t = Ax_t + Bu_t + F(x_t \otimes u_t) + w_t</span>
0025 <span class="comment">%   y_t = Cx_t + Du_t + G(x_t \otimes u_t) + e_t</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%  with w_t and e_t being state and measurement noise.  In the purely</span>
0028 <span class="comment">%  linear modelling case, F and G are set to zero, but otherwise a</span>
0029 <span class="comment">%  bilinear model is estimated.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%  Usage is</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%  G = est(Z,M,OPT);</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%  where:</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%   Z:          Input-Output data in one of two forms.  The standard form</span>
0038 <span class="comment">%               is for it to be a record with elements Z.y and Z.u, each</span>
0039 <span class="comment">%               of which are matrices with number of rows equal to the</span>
0040 <span class="comment">%               number of data samples, and number of columns equal (respectively)</span>
0041 <span class="comment">%               to the number of outputs and the number of inputs.  On</span>
0042 <span class="comment">%               the other hand, Z can be a matrix of the form Z = [y,u]</span>
0043 <span class="comment">%               where it is assumed that y is a column vector of output</span>
0044 <span class="comment">%               measurements and u is a matrix whose columns are the</span>
0045 <span class="comment">%               input measurements; in this latter MISO models are</span>
0046 <span class="comment">%               being considered.</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%               In Addition, both non-equidistant time domain data, and</span>
0049 <span class="comment">%               frequency domain data can also be supplied via Z. Please</span>
0050 <span class="comment">%               type &quot;help startZ&quot; at the command prompt for further</span>
0051 <span class="comment">%               details.</span>
0052 <span class="comment">%</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%  M:           Data structure which defines the model structure which</span>
0055 <span class="comment">%               is to be estimated from the data as follows:</span>
0056 <span class="comment">%    M.A,M.B:   Initial guess for input-output dynamics.  If these are</span>
0057 <span class="comment">%               given as integers, then they are interpreted as</span>
0058 <span class="comment">%               specifications of the numbers of zeros in M.A and M.B.</span>
0059 <span class="comment">%               Each row of M.A or M.B specifies initiation of on i/o</span>
0060 <span class="comment">%               component of possible MISO model.  Any poly spec is</span>
0061 <span class="comment">%               interpreted in *decreasing* powers of p, starting at</span>
0062 <span class="comment">%               zeroth power.  Pad with trailing zeros if necessary to</span>
0063 <span class="comment">%               make all rows of same length.</span>
0064 <span class="comment">%    M.C,M.D:   Initial guess for measurement noise model.  If not</span>
0065 <span class="comment">%               specified, or specified as empty matrices, then</span>
0066 <span class="comment">%               the default is C/D 1; If M.C and M.D are specified as</span>
0067 <span class="comment">%                     integers, then this is interpreted as the number of poles</span>
0068 <span class="comment">%                     and zeros to be estimated in C and D.</span>
0069 <span class="comment">%    M.delay:   Number of samples of delay to include (see above model).</span>
0070 <span class="comment">%               In the case of a MISO system, this should be a vector of</span>
0071 <span class="comment">%               delays, one for each input being considered.  Default is</span>
0072 <span class="comment">%               delays are all equal to zero.</span>
0073 <span class="comment">%    M.op:      Set to 'q' for shift and 'd' for delta.  Default = 'q'.</span>
0074 <span class="comment">%    M.T:       Sampling period in s. (Ignored for q case) Default = 1;</span>
0075 <span class="comment">%    M.w:       Vector of frequencies at which to calculate frequency</span>
0076 <span class="comment">%               response of estimated model.  Specify in real frequency,</span>
0077 <span class="comment">%               not normalised.  Default is 3 decades up to folding freq.</span>
0078 <span class="comment">%    M.type:    Type of model structure for linear dynamics estimation.</span>
0079 <span class="comment">%               Valid types are: 'arma','fir','arx','armax','oe','bj' for</span>
0080 <span class="comment">%               polynomial models, 'ss' for a linear state space model,</span>
0081 <span class="comment">%               and 'bilinear' for a bilinear state space model.</span>
0082 <span class="comment">%               If M.type is not specified, it is guessed from how</span>
0083 <span class="comment">%               M.A,M.B, M.C and M.D are specified.</span>
0084 <span class="comment">%    M.in(k):   Structure that defines any static non-linearities on the</span>
0085 <span class="comment">%               k'th input. This structure contains an element M.in(k).type</span>
0086 <span class="comment">%               whose default value is `linear', but may be set to the</span>
0087 <span class="comment">%               following other values in which case other elements of</span>
0088 <span class="comment">%               M.in(k) (as indicated) may also be set:</span>
0089 <span class="comment">%M.in(k).type:  'poly'.  This fits a polynomial model to the input</span>
0090 <span class="comment">%               non-linearity, in which case M.in.eta specifies either</span>
0091 <span class="comment">%               (if a single integer) the order of the polynomial or (if</span>
0092 <span class="comment">%               a vector) an initial guess at the terms in the</span>
0093 <span class="comment">%               polynomial.  If M.in.eta is not specified, then a default</span>
0094 <span class="comment">%               cubic model is used.</span>
0095 <span class="comment">%M.in(k).type:  'hinge'.  This fits a `hinging hyperplane' (ie. peicewise</span>
0096 <span class="comment">%               linear) model to the input non-linearity. In which case</span>
0097 <span class="comment">%               M.in.eta specifies the piecewise linearity in a fashion</span>
0098 <span class="comment">%               impossible to document quickly here.  The default is a</span>
0099 <span class="comment">%               deadzone shape non-linearity.</span>
0100 <span class="comment">%       M.par:  Specification of state-space parametrisation used in</span>
0101 <span class="comment">%               Gauss--Newton algorithm. This may be one of:</span>
0102 <span class="comment">%               'ddlc' : Data-Driven-Local-Coordinates - default for</span>
0103 <span class="comment">%                        state-space models (both linear and bilinear).</span>
0104 <span class="comment">%               'full' : Full parametrisation.</span>
0105 <span class="comment">%  OPT:         Data structure which defines options for the estimation</span>
0106 <span class="comment">%               algorithm as follows:</span>
0107 <span class="comment">%    OPT.alg:   Specification of estimation algorithm to use.  This may</span>
0108 <span class="comment">%               be one of:</span>
0109 <span class="comment">%               'gn' : Gradient based search via damped Gauss--Newton</span>
0110 <span class="comment">%                      algorithm - default for SISO or MISO models.</span>
0111 <span class="comment">%               'em' : Maximum likelihood estimation via EM algorithm</span>
0112 <span class="comment">%                      iterative search - default for MIMO models.</span>
0113 <span class="comment">%    'n4sid' or 'sid': N4SID Subspace based system identification method.</span>
0114 <span class="comment">%               'cca': Canonical Correlation Analysis method.</span>
0115 <span class="comment">%</span>
0116 <span class="comment">%                The default is OPT.alg='gn' for SISO and MISO systems,</span>
0117 <span class="comment">%                but OPT.alg='em' as a default for MIMO systems.</span>
0118 <span class="comment">%    OPT.dir:   Search direction for gradient based search method, can be</span>
0119 <span class="comment">%               'rgn' for robust Gauss-Newton, 'lm' for</span>
0120 <span class="comment">%               Levenberg-Marquardt, 'trust' for trust region, 'bfgs' for</span>
0121 <span class="comment">%               quasi-Newton method, 'grad' for pure gradient search.</span>
0122 <span class="comment">%    OPT.cost:  Can be 'trace' to minimise trace of sum of squared errors,</span>
0123 <span class="comment">%               or 'det' to minimise the log determinant of the sum of</span>
0124 <span class="comment">%               outer product of error vectos (related to Maximum-Likelihood)</span>
0125 <span class="comment">%    OPT.dsp:   Optional, set to something non-zero for verbose output.</span>
0126 <span class="comment">%               Default is OPT.dsp=0;</span>
0127 <span class="comment">%    OPT.n:     Number of starting data points to discard to get</span>
0128 <span class="comment">%               rid of initial condition effects.  Default is none.</span>
0129 <span class="comment">%    OPT.delta: Regularisation value for Levenberg-Marquardt and Trust</span>
0130 <span class="comment">%               region search methods.</span>
0131 <span class="comment">%    OPT.step:  Number of prediction samples ahead to use in cost</span>
0132 <span class="comment">%               criterion - only applies for OPT.alg='gn'.  Default is OPT.step=1;</span>
0133 <span class="comment">%    OPT.miter: Maximum number of updates of estimate from initial guess.</span>
0134 <span class="comment">%               Default is 200.</span>
0135 <span class="comment">%    OPT.tol:   If normalised gradient is less than OPT.tol, then gn</span>
0136 <span class="comment">%               algorithm will terminate</span>
0137 <span class="comment">%    OPT.lmax:  Maximum number of times search distance will be shortened</span>
0138 <span class="comment">%               by bisection.  Default is 52.</span>
0139 <span class="comment">%    OPT.mdec:  Minimum relative decrease of cost before search is</span>
0140 <span class="comment">%               terminated.  Default is 1e-9;</span>
0141 <span class="comment">%    OPT.fast:  When set to 1, then makes algorithm run maximally fast by</span>
0142 <span class="comment">%               avoiding the calculation of error bounds.  Default is 0.</span>
0143 <span class="comment">%</span>
0144 <span class="comment">%  G:           Data structure which specifies the estimated model as</span>
0145 <span class="comment">%               follows:</span>
0146 <span class="comment">% G.A, G.B:     Matrices definining the estimated transfer function model.</span>
0147 <span class="comment">% G.C, G.D:     For SISO systems, these element are row vectors defining</span>
0148 <span class="comment">%               co-efficients of increasing powers of M.op^-1.  For MISO,</span>
0149 <span class="comment">%               they are matrices of rows, the k't row pertaining to the</span>
0150 <span class="comment">%               k'th input.  For MIMO, they are 3 dim matrices with the</span>
0151 <span class="comment">%               row (k,:,m) defining the transfer function from the k'th</span>
0152 <span class="comment">%               input to the m'th output.</span>
0153 <span class="comment">% G.ss.A,B,C:   [A,B,C,D,F,G] matrices/vectors defining estimated model in</span>
0154 <span class="comment">%      D,F,G:   state space form.</span>
0155 <span class="comment">% G.ss.X0,P0:   EM algorithm case only - estimate of ic's;</span>
0156 <span class="comment">%    G.G:       Matrix of frequency responses.  If the system has multiple</span>
0157 <span class="comment">%               inputs and multiple outputs, then this matrix is 3</span>
0158 <span class="comment">%               dimensional, with one `page' per output, and the i'th</span>
0159 <span class="comment">%               column of the j'th page (ie G.G(:,i,j)) being the</span>
0160 <span class="comment">%               frequency response from input i to ouput j.</span>
0161 <span class="comment">%    G.H:       Frequency response of estimated spectral factor of</span>
0162 <span class="comment">%               measurement noise - may be multivariable as above.</span>
0163 <span class="comment">%    G.Ge:      Matrix specifying 95% confidence regions for estimated</span>
0164 <span class="comment">%               frequency response Ghat.  They may be plotted by using either</span>
0165 <span class="comment">%               of the commands `shownyq(G)' or `showbode(G)'.</span>
0166 <span class="comment">%    G.Gvar:    Vector which is var(G(w)), one element per element in G.w.</span>
0167 <span class="comment">%    G.P:       Covariance Matrix for Estimated Parameters.</span>
0168 <span class="comment">%    G.th:      Parameter estimates as a column vector.</span>
0169 <span class="comment">%    G.mse:     Evolution of mean square cost decrease as any iterative</span>
0170 <span class="comment">%               algorithm (em, gn) progresses;</span>
0171 <span class="comment">%    G.LL:      EM algorithm only - evolution of log likelihood increase.</span>
0172 <span class="comment">%</span>
0173 <span class="comment">%   written by Brett Ninness, School of EE &amp; CS</span>
0174 <span class="comment">%              Adrian Wills   University of Newcastle</span>
0175 <span class="comment">%                               Australia.</span>
0176 
0177 
0178 <span class="comment">% Copyright (C) Brett Ninness</span>
0179 
0180 <a name="_sub0" href="#_subfunctions" class="code">function G = est(Z,M,OPT)</a>
0181 
0182 <span class="comment">%--------------------------------------------------------------------------</span>
0183 <span class="comment">%  Sanity checks on inputs</span>
0184 <span class="comment">%--------------------------------------------------------------------------</span>
0185 <span class="keyword">if</span> nargin==0,
0186  <span class="keyword">try</span>
0187   west = which(<span class="string">'est'</span>);
0188   i = strfind(west,<span class="string">'est.m'</span>);
0189   addpath([west(1:i-1) <span class="string">'../gui_java'</span>]);
0190   unitGuiJava;
0191   <span class="keyword">return</span>;
0192  <span class="keyword">catch</span>
0193   disp(<span class="string">'Sorry, no GUI available'</span>)
0194  <span class="keyword">end</span>
0195 <span class="keyword">elseif</span> nargin&lt;1,
0196  error(<span class="string">'Need to specify data (Z)!'</span>);
0197 <span class="keyword">elseif</span> nargin&lt;2,
0198     <span class="comment">%Assume that the user has only supplied data so try to guess an</span>
0199     <span class="comment">%appropriate model order via subspace algorithm</span>
0200  Z    = <a href="startZ.html" class="code" title="function Z = startZ(Z)">startZ</a>(Z);
0201  m.nx = min(20,ceil(Z.Ny/10));
0202  gsid = <a href="subspace.html" class="code" title="function G = subspace(Z,M,OPT)">subspace</a>(Z,m);
0203  lsin = length(gsid.sing); 
0204  vv   = [linspace(0,(lsin-1)/lsin,lsin) ; gsid.sing(:)'/gsid.sing(1)];
0205  [mv,mi] = min(sum(vv.*vv));
0206  M.A  = mi+1;
0207  OPT  = [];
0208 <span class="keyword">elseif</span> nargin&lt;3,
0209  OPT=[];
0210 <span class="keyword">end</span>
0211 
0212 <span class="comment">%Detect if gui is running</span>
0213 gui = 0; guih = [];
0214 <span class="keyword">if</span> isfield(OPT,<span class="string">'gui'</span>),
0215  <span class="keyword">if</span> ~isempty(OPT.gui)
0216   gui  = 1;         <span class="comment">%GUI is running</span>
0217   guih = OPT.gui;   <span class="comment">%GUI handle</span>
0218  <span class="keyword">end</span>
0219 <span class="keyword">end</span>
0220 
0221 <span class="comment">%--------------------------------------------------------------------------</span>
0222 <span class="comment">%  Unspecified data components-&gt;defaults                  DATA</span>
0223 <span class="comment">%--------------------------------------------------------------------------</span>
0224 
0225 Z   = <a href="startZ.html" class="code" title="function Z = startZ(Z)">startZ</a>(Z);
0226 
0227 <span class="comment">%--------------------------------------------------------------------------</span>
0228 <span class="comment">%  Unspecified model structure components-&gt;defaults       MODEL</span>
0229 <span class="comment">%--------------------------------------------------------------------------</span>
0230 
0231 M  = <a href="startM.html" class="code" title="function M = startM(varargin)">startM</a>(Z,M);
0232 
0233 <span class="comment">%--------------------------------------------------------------------------</span>
0234 <span class="comment">%  Unspecified estimation options-&gt;defaults               ALGORITHM</span>
0235 <span class="comment">%--------------------------------------------------------------------------</span>
0236 
0237 OPT = <a href="startOPT.html" class="code" title="function OPT = startOPT(OPTin,Min)">startOPT</a>(OPT,M);
0238 
0239 <span class="comment">%--------------------------------------------------------------------------</span>
0240 <span class="comment">%  Determine what estimate initialisation is required, and what</span>
0241 <span class="comment">%  estimation algorithm should be used.</span>
0242 <span class="comment">%--------------------------------------------------------------------------</span>
0243 
0244 ep  = <a href="estmap.html" class="code" title="function ep = estmap(Z,M,OPT);">estmap</a>(Z,M,OPT);
0245 
0246 <span class="comment">%--------------------------------------------------------------------------</span>
0247 <span class="comment">%  Display start of estimation process</span>
0248 <span class="comment">%--------------------------------------------------------------------------</span>
0249 
0250 <span class="keyword">if</span> OPT.dsp,
0251  dblines=<span class="string">'======================================================================================'</span>;
0252  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>([sprintf(<span class="string">'\n'</span>) dblines],gui,guih);
0253  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'START ESTIMATION PROCESS:'</span>,gui,guih);
0254  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>([<span class="string">'Estimating parameters for &quot;'</span> upper(M.type) <span class="string">'&quot; model structure using &quot;'</span> lower(M.op) <span class="string">'&quot; operator.'</span>],gui,guih);
0255  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(ep.modelEquations,gui,guih);
0256  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'INITIALISATION:'</span>,gui,guih);
0257 <span class="keyword">end</span>
0258 
0259 <span class="comment">%--------------------------------------------------------------------------</span>
0260 <span class="comment">%  Initialise Nonlinear parts of model if necessary</span>
0261 <span class="comment">%--------------------------------------------------------------------------</span>
0262 
0263 <span class="keyword">if</span> ~isempty(ep.startNL),
0264  M = feval(ep.startNL,Z,M); <span class="comment">%calling startNL</span>
0265 <span class="keyword">elseif</span> OPT.dsp,
0266  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'No initialisation of Nonlinear structure required.'</span>,gui,guih);
0267 <span class="keyword">end</span>
0268 
0269 <span class="comment">%--------------------------------------------------------------------------</span>
0270 <span class="comment">%  Initialise estimate of system dynamics if necessary</span>
0271 <span class="comment">%--------------------------------------------------------------------------</span>
0272 
0273 <span class="keyword">if</span> ~isempty(ep.startG),
0274  M = feval(ep.startG,Z,M,OPT); <span class="comment">%calling startG</span>
0275 <span class="keyword">elseif</span> OPT.dsp,
0276  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'No initialisation of model dynamics required.'</span>,gui,guih);
0277 <span class="keyword">end</span>
0278 
0279 <span class="comment">%--------------------------------------------------------------------------</span>
0280 <span class="comment">%  Initialise noise model if necessary</span>
0281 <span class="comment">%--------------------------------------------------------------------------</span>
0282 
0283 <span class="keyword">if</span> ~isempty(ep.startH),
0284  M = feval(ep.startH,Z,M,OPT); <span class="comment">%calling startH</span>
0285 <span class="keyword">elseif</span> OPT.dsp,
0286  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'No initialisation of noise dynamics required.'</span>,gui,guih);
0287 <span class="keyword">end</span>
0288 
0289 <span class="comment">%--------------------------------------------------------------------------</span>
0290 <span class="comment">%  Now call appropriate estimation algorithm</span>
0291 <span class="comment">%--------------------------------------------------------------------------</span>
0292 
0293 <span class="keyword">if</span> ~isempty(ep.alg),
0294  M = feval(ep.alg,Z,M,OPT); <span class="comment">% Call main alg, e.g. gn or em</span>
0295 <span class="keyword">elseif</span> OPT.dsp,
0296  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'No main algorithm required.'</span>,gui,guih);
0297 <span class="keyword">end</span>
0298 
0299 <span class="comment">%--------------------------------------------------------------------------</span>
0300 <span class="comment">%  Fill in all components of returned (estimated) model structure</span>
0301 <span class="comment">%--------------------------------------------------------------------------</span>
0302 
0303 <span class="keyword">if</span> ~isempty(ep.finishM),
0304  G = feval(M.finishM,Z,M,OPT); 
0305 <span class="keyword">elseif</span> OPT.dsp,
0306  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'No model finishing required.'</span>,gui,guih);
0307 <span class="keyword">end</span>
0308 
0309 
0310 <span class="comment">%--------------------------------------------------------------------------</span>
0311 <span class="comment">%  Display end of estimation process</span>
0312 <span class="comment">%--------------------------------------------------------------------------</span>
0313 
0314 <span class="keyword">if</span> OPT.dsp,
0315  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>(<span class="string">'END ESTIMATION PROCESS'</span>,gui,guih);
0316  <a href="udisp.html" class="code" title="function udisp(str,guiRunning,guiHandle)">udisp</a>([dblines sprintf(<span class="string">'\n'</span>)],gui,guih);
0317 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 04-May-2025 22:15:31 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>